#+LATEX_CLASS: article
#+STARTUP: latexpreview
#+LANGUAGE: en
#+OPTIONS: toc:nil
#+OPTIONS: latex:t

#+LATEX_CLASS_OPTIONS: [a4paper,12pt,twocolumn]

#+LATEX_HEADER: \usepackage[lite,subscriptcorrection,slantedGreek,nofontinfo]{mtpro2}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{color}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \lstset{language=Scheme,frame=lines}
#+LATEX_HEADER: \definecolor{codegreen}{rgb}{0,0.6,0}
#+LATEX_HEADER: \definecolor{codegray}{rgb}{0.5,0.5,0.5}
#+LATEX_HEADER: \definecolor{backcolour}{rgb}{0.95,0.95,0.92}
#+LATEX_HEADER: \title{Compile with CPS}

#+LATEX_HEADER: \author{Nala Ginrut}

#+AUTHOR:
#+DATE:
#+LATEX_HEADER: \maketitle

#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+STARTUP: indent

* Terms
** Weak beta reduction
   The abstract won't be further reduced, or the abstract is treated as normal form. Same meaning.
** Full beta reduction
   All possible orders can be sound.
** Normalization
   Performing beta and eta reduction to archieve normal forms.
** Unbox
Represent the value with a single CPU machine word in replace of a pointer.
* Design
** Primitive types
All primitive types are wrapped into cps-value
*** Integer
- unboxed
*** String
- char buf (boxed)
*** Container
- string, vector, list, pair
- cps-container
** Branch
** Collection
cons, list, vector
#+begin_src scheme
(define-record-type cps-collection
  (fields

  )
#+end_src
** String
* CPS
** Two flavors CPS
*** Higher order CPS
*** First order CPS
** CPS vs. ANF

|     | what's k                 | shrinking reduction         |   |   |
|-----+--------------------------+-----------------------------+---+---|
| CPS | a continuation wrapped   | $O(n)$ for linear reduction  |   |   |
|     | an expr which computes   |                             |   |   |
|     | the result               |                             |   |   |
|-----+--------------------------+-----------------------------+---+---|
| ANF | a var bounded the result | $O(n^2)$ in the worse case    |   |   |
|     | of a trival expr         | commuting conversion        |   |   |
|-----+--------------------------+-----------------------------+---+---|

** CPS vs. Monads

|        | what's k                 | shrinking reduction         |   |   |
|--------+--------------------------+-----------------------------+---+---|
| CPS    | a continuation wrapped   | $O(n)$ for linear reduction  |   |   |
|        | an expr which computes   |                             |   |   |
|        | the result               |                             |   |   |
|--------+--------------------------+-----------------------------+---+---|
| Monads |                          | $O(n^2)$ in the worse case    |   |   |
|        |                          | commuting conversion        |   |   |
|--------+--------------------------+-----------------------------+---+---|

** Benefit
   1. All exprs in arguments are transformed to atomics (variables & constants).
      - This is good for assembly: application or abstract can't be in argument when the program to assembly.
      - CPS is suit for Von Neumann machine.
   2. ANF or Monads leads to O(n^2) in worse case because of commuting conversions.
      - While CPS only needs O(n) according to Appel & Jim 1992.

   case-2: Let's say c is the cnd of a branch, if c is permantly true or false, then the alternative branch k can be eliminated by case-1.
** Transformation
   1. CPS has no standard transformation algorithm, so it was hard to use. But after many reserchers' efforts, there're some good transformations were found.
   2. In compilation, it's uncessary to use full-CPS which demands primitives are in CPS, so we have to seperate them:
      - In primitives application: $(p\ e)$ => $\lambda k.\ (k\ (p\ e))$
      - In functions application: $(f\ e)$ => $\lambda k.\ (f'\ k\ e)$

   3. The function must be defined as a dedicated form, lambda or record-type. It's impossible to recognize.
   4. One-pass: Doesn't introduce /administrative redex/
   5. According to Kennedy's transform algorithm, we need two converters:
      - 1. expr->cps which takes the continuation as a symbol for its own name
      - 2. cps-comp which takes the continuation as an actual context that can
           be applied in the translation-time.
      The point is to isolate the /administrative redex/ introduced in the translation-time to cps-comp, then eliminate them during the CPS translation.
   6. Make a syntactic distinction between:
      1. /functions/
         - Could be the heap-allocated clousre
         - Can be transformed to continuation by /contification/
      2. /local continuations/
         Could always be the inlined code with jumps
   7. CPS optimization
      1. CPS is inefficient, we have to optimize it before next step
   8. Closure introducing
      2. Closure conversion
** CPS design
1. Distinct value-cps and cont-cps
2. Args are just one list
3. Pair and List derives from the same record cps-container
** Compiling process
*** expr->cps
*** Shrink
*** normalize
**** Eta-reduction
**** Beta-reduction
*** Micro Pass (optimizing)
*** closure-conversion
*** contification
function calling -> local control-flow
** Compiling optimizing
*** Partial evaluation
*** Constant folding
If:
   1. i is constant and not free in M
   2. p is primitive
Then:
   i or p(i) can be folded as a constant.

*Fold:* substitute i in M first, then pass the result to the continuation.
**** Arithmetic constant folding
*Exampt:* The arithmetic operation will raise an exception. For example, $1\div0$
Possible pattern:
1. elementary arithmetic
2. length function
3. logic arithmetic
4. char->integer
**** String constant folding
**** Comparison constant folding
1. Operands are integer
2. The function is comparison operator
Can be further folding branching CPS in [[Dead code elimination]].
*** Copy propagation
*** Functions
If each continuation was named, then the copy-propagation of functions can be done by eta-reduction.
E.g:
    #+BEGIN_SRC scheme :exports code
    (let* ((f (lambda (x) (* x x)))
          (h (lambda (x) (f x)))
          (g (lambda (x k) (+ x (k 9)))))
      (+ 3 (g 8 h)))
      ;; h = f
      ;; 3 + 8 + h(9)
    #+END_SRC

We've noticed that h is actually the abstraction of f, so it obviously can be reduced by eta-reduction.
    #+BEGIN_SRC scheme :exports code
    (let* ((f (lambda (x) (* x x)))
           (g (lambda (x) (+ x (k 9)))))
      (+ 3 (g 8 f)))
    ;; 3 + 8 + f(9)
    #+END_SRC
*** Inlining
If we do beta-reduction on the function that only applied once in the context, then we can remove the definition of this function. This is called function-inlining.
Steps:
1. if M is bound to a function f
2. substitute f with M in the continuation
3. remove the definition of f.
*NOTE:* Usually, there must be an alpha-renaming step to make sure every variable is unique. Our CPS transformation has renamed each *fresh variable*, however, the original variable is not renamed.
*** Dead variable elimination
There're three conditions, if a variable:
1. won't raise an exception (by primitive type checking)
2. can't be modified (immutable)
3. never used
iff 1,2,3 meet, then this variable could be removed.

*** Dead code elimination
*** Flatten arguments
*** Flatten collection
*** Dropping unused arguments
*** Analysis of operation on the store
An assignment into the store followed by a fetch from the same location can be analyzed, eliminating the fetch.
1. fetch
2. store
Then fetch can be eliminated. This should be worth for embedded system.
*** Uncurrying
IMO, cps-fv is easier after uncurrying.
** About side-effects
   1. The side-effects in syntax won't be able to affect the optimizings, because they're explicit in the syntax, so we can handle them.
   2. Only side-effects in pritimitives should be considered.
